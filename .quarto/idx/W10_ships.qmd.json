{"title":"Ship Detection","markdown":{"headingText":"Ship Detection","containsRefs":false,"markdown":"\nThere's a huge amount of data available on the internet about ship movements, most of which draw on the Automatic Identification System (AIS) which is a system that uses radio to broadcast the identity, position, course, speed, and other data about ships. [MarineTraffic](https://www.marinetraffic.com/en/ais-api-services), for example, provides an API that allows you to query the location of ships in real time as well as historical vessel tracks and lots of other useful data. Unfortunately most sources of AIS data are paywalled, and AIS can be turned off or manipulated to hide the identity or position of the ship. In fact, most of the stuff we're interested in investigating probably happens when AIS is turned off. \n\nThough ships can hide by turning off their AIS transponders, they can't hide from satellites. In this tutorial, we're going to build an application that uses Synthetic Aperture Radar (SAR) from the European Space Agency's Sentinel-1 satellite to automatically identify ships, regardless of whether they've got their transponders turned on or off. Here's the finished application:\n\n:::{.column-page}\n\n<iframe src='https://ollielballinger.users.earthengine.app/view/shipdetection' width='100%' height='700px'></iframe>\n\n:::\n\n## How it Works \n\nThe app has two main panels:\n\n1.  A control panel on the left that allows the user to interact with the application \n2.  A map on the right that displays the results\n\nThe control panel has a date slider that allows the user to load imagery from a particular year. Below that is a graph that shows the number of ships detected over time within that year. A slider underneath the graph lets us toggle the sensitivity of the ship detection process. Finally, a button at the bottom lets the user draw their own area of interest on the map, and the app will automatically detect ships within that area.\n\nThe map panel visualizes the results of the ship detection process and has three layers. The bottom layer is the Sentinel-1 image that we're using to detect ships; it's blue/purple, and if you zoom in and look closley you can see bright specks in the sea, which are ships. When Sentinel-1 sends a pulse of radio waves onto a flat surface like the sea, there is very little to reflect the waves back to the satellite-- they just bounce off into space. A low return signal means we'll see a darker color on our map. But when the raio waves hit a ship they are reflected back to the satelite and generate a higher return signal, and therefore a much brighter color. The second layer on the map displays a bunch of green points; each one of these is a detected ship. The last layer shows the red outline of the area of interest that the user drew on the map. You can zoom in on the map by holding down the command button and scrolling up and down.\n\nWhen the application is first loaded it is centered on an area just north of the Suez Canal, and is analyzing imagery from 2021. We can see a bunch of green dots in the AOI, which is the main waiting area for ships waiting to transit the canal. It's a bit crowded because it's visualizing all of the ships detected in the entire year. We can display imagery from a single day by clicking on a point in the graph on the left, which you will notice displays a huge spike in the number of ships detected around March. \n\nYou might remember that on March 23rd, 2021, the Ever Given-- a 400m long container ship-- got stuck in the Suez Canal. The ship was blocking the canal for six days, and it's estimated that it cost the global economy $400 million per day. If you click on the tip of the spike on March 30th, you can see backup of around 150 ships waiting for the canal to be cleared. You can also zoom in on a particular date range by scrolling and dragging on the graph. If you zoom in on the spike, you can then select imagery from early April to compare the number of ships in the waiting area after the blockage was cleared. In normal times we can see a regular pattern in the number of ships in the waiting area ranging between 15 and 40 ships. \n\nIf you're closely zoomed in to the map and load imagery from different days by clicking on the graph, you can compare the bright spots on the Sentinel image and the green dots. The ship detection process is pretty accurate, and we typically see one green dot per ship. However, you may notice that we occasionally miss a ship. This is because the ship detection process is based on a threshold, and if the ship is too small it may not generate a high enough return signal to be detected. You can increase the sensitivity of the ship detection process by moving the slider below the graph. This will increase the number of ships detected, but it may also increase the number of false positives. \n\nThe next section focuses on building this application. After that, we'll have a look at a few different use cases for this sort of maritime surveillance. \n\n# Building the Application\n\n## Setup \n\nThe first step is to configure the map and import the necessary datasets. By default, we want the app to be centered on the Suez Canal. Then, we want to import the Digital Surface Model (DSM) from the ALOS World 3D-30 dataset. This dataset provides a 30m resolution elevation model of the Earth which we will use to mask out the land. Finally, we want to import the Sentinel 1 dataset. We will use the VV polarization and the Interferometric Wide (IW) mode. We will also sort the images by date.\n\n```js\n// Center the map on the Suez Canal and set map options\nMap.setCenter(32.327, 31.4532, 10);\nMap.setOptions(\"Hybrid\");\nMap.setControlVisibility({ all: false });\n\n// Import the Digital Surface Model (DSM) from the ALOS World 3D-30 dataset\nvar dem = ee.ImageCollection(\"JAXA/ALOS/AW3D30/V3_2\").mean().select(\"DSM\");\n\n// Import the Sentinel 1 dataset\nvar s1 = ee\n  .ImageCollection(\"COPERNICUS/S1_GRD\")\n  .filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VV\"))\n  .filter(ee.Filter.eq(\"instrumentMode\", \"IW\"))\n  .sort(\"system:time_start\");\n\n// Define the default area of interest\nvar suez = ee.Geometry.Polygon([\n  [\n    [32.17388584692775, 31.59541178442045],\n    [32.17388584692775, 31.327159861902278],\n    [32.4787564523965, 31.327159861902278],\n    [32.4787564523965, 31.59541178442045],\n  ],\n]);\n```\n\nNow that we've gotten that out of the way, we can move on to the actual detection of ships. \n\n## Ship Detection\n\nYou might expect the automatic identification of ships based on synthetic aperture radar satellite imagery to involve a complex machine learning algorithm or artificial intelligence. In fact, it can be done in one line of code which sets a cutoff. If the return signal is greater than 0, then we have a ship. If it's less than 0, then we don't. Simple as that. \n\nThe main analytical function responsible for ship identification is the `getVectors` function shown below. It takes an image as an input and returns a FeatureCollection of points, each corresponding to a ship. The function clips the image to the area of interest, selects the VV polarization, and finally filters out areas where the VV value is smaller than 0. This results in a raster image where the sea is black and the ships are white. We then use the `reduceToVectors` function to convert the raster image to a FeatureCollection of points. The function returns this FeatureCollection, and sets a property called `count` which is the number of ships detected in the image. \n\n```js \nfunction getVectors(img) {\n  // Get the area of interest from the drawing tools widget.  \n  var aoi = drawingTools.layers().get(0).getEeObject();\n\n  // Clip the image to the area of interest\n  // Select the VV polarization \n  // Filter areas where the VV value is greater than 0\n  var cutoff = img.clip(aoi).select(\"VV\").gt(0)\n\n  // Convert the raster image to a FeatureCollection of points\n  var points = cutoff.reduceToVectors({\n    geometry: aoi,\n    scale: scaleSlider.getValue(),\n    geometryType: \"centroid\",\n    eightConnected: true,\n    maxPixels: 1653602926,\n  });\n\n  // Set the number of ships detected in the image as a property called \"count\"\n  var count = points.size();\n  // Set the date of the image as a property called \"system:time_start\"\n  var date = ee.Date(img.get(\"system:time_start\"));\n  return points.set(\"count\", count).set(\"system:time_start\", date);\n}\n```\nThe `count` and `system:time_start` properties are used to create the graph of daily ship counts and allow the resulting vector (point) data to interact with the date slider widget. An important detail here is that the \"scale\" parameter of the `reduceToVectors` function is set to the value of the scale slider widget. This allows the user to adjust the resolution of the ship detection process; a smaller value will allow us to detect smaller ships. \n\n## Visualization\n\nThe `viz` function is responsible for displaying the results of the ship detection process. It takes the area of interest, the vector data, and the Sentinel 1 image as inputs. Nothing super complicated here; we're just creating three layers and adding them to the map in order: the underlying Sentinel-1 image raster, the ship vector data in green, and the area of interest outline in red. We're using the `Map.layers().set()` function to replace the existing layers with the new ones, rather than addine new ones each time.\n\n```js \nfunction viz(aoi, vectors, s1Filtered) {\n  // Create an empty image into which to paint the features, cast to byte.\n  var empty = ee.Image().byte();\n\n  // Paint all the polygon edges with the same number and width, display.\n  var outline = empty.paint({\n    featureCollection: aoi,\n    color: 1,\n    width: 3,\n  });\n\n  // Create a layer for the area of interest in red\n  var aoi_layer = ui.Map.Layer(outline, { palette: \"red\" }, \"AOI\");\n\n  // Create a layer for the vector data in green\n  var vectorLayer = ui.Map.Layer(\n    vectors.flatten(),\n    { color: \"#39ff14\" },\n    \"Vectors\"\n  );\n\n  // Create a layer for the Sentinel 1 image in false color\n  var sarLayer = ui.Map.Layer(\n    s1Filtered,\n    { min: [-25, -20, -25], max: [0, 10, 0], opacity: 0.8 },\n    \"SAR\"\n  );\n\n  // Add the layers in order\n  Map.layers().set(0, sarLayer);\n  Map.layers().set(1, vectorLayer);\n  Map.layers().set(2, aoi_layer);\n}\n```\nWe want a function to handle the visualization because there are two different situations in which we're going to visualize results, and we dont want to repeat our code. The first situation is when the user draws a new area of interest, moves the date slider, or alters the scale. In this case, we want to visualize the results of the ship detection process for the entire year's worth of Sentinel-1 imagery. The second situation is when the user clicks on the chart to analyze a particular day. In this case, we obviously only want to visualize the results of the ship detection process on that day. With this function, we can simply pass the appropriately filtered versions of the Sentinel-1 image and vector data to the function, and it will visualize the results, rather than having to write the same code twice.\n\n## Putting it all together \n\nHaving defined a few helper functions to handle the visualization and ship detection process, we can now move on to the main function that will perform the analysis. This will be performed by the `daterangeVectors` function. In a nutshell, it read the user specified date range from the date slider widget, and filter the Sentinel 1 dataset to only include images within that period. Then, it will loop through each Sentinel-1 image from that year and apply the `getVectors` function to count the number of ships that fall within the area of interest and generate a dataset of points corresponding to detected ships. We'll then use the `viz` function we just defined to visualize the all of the ship detections and Sentinel-1 images in the AOI during that year stacked on top of each other. Finally, we'll create a chart based on the number of ships detected per day, and allow the user to click on the chart to visualize the results for a particular day.\n\n```js\nvar daterangeVectors = function () {\n  \n  // Get the date range from the date slider widget.\n  var range = ee.DateRange(\n    ee.Date(dateSlider.getValue()[0]),\n    ee.Date(dateSlider.getValue()[1])\n  );\n\n  // Get the area of interest from the drawing tools widget.\n  var aoi = drawingTools.layers().get(0).getEeObject();\n\n  // Hide the user-drawn shape.\n  drawingTools.layers().get(0).setShown(false);\n\n  // Filter the Sentinel 1 dataset to only include images within the date range, and within the area of interest.\n  var s1Filtered = s1.filterDate(range.start(), range.end()).filterBounds(aoi);\n  \n  // Count the number of ships in each image using the getVectors function\n  var vectors = s1Filtered.map(getVectors);\n\n  // Use the viz function to visualize the results \n  viz(aoi, vectors, s1Filtered.max().updateMask(dem.lte(0)));\n\n  // Create a chart of the number of ships per day\n  var chart = ui.Chart.feature\n    .byFeature({\n      features: vectors,\n      xProperty: \"system:time_start\",\n      yProperties: [\"count\"],\n    })\n    .setOptions({\n      title: \"Daily Number of Ships in Area of Interest\",\n      vAxis: { title: \"Ship Count\" },\n      explorer: { axis: \"horizontal\" },\n      lineWidth: 2,\n      series: \"Area of Interest\",\n    });\n\n  // Add the chart at a fixed position, so that new charts overwrite older ones.\n  controlPanel.widgets().set(4, chart);\n\n  // Add a click handler to the chart to filter the map by day.\n  chart.onClick(filterDay);\n};\n```\n\nThere's one function referenced above-- `filterDay`-- that we haven't defined yet. This function is called when the user clicks on the chart to analyze a particular day. It takes the date of the clicked day as an input, filters the Sentinel-1 dataset and vector data accordingly, and uses the `viz` function to display the results for that day.\n\n```js\nfunction filterDay (callback) {\n\n    // Get the date of the clicked day\n    var date = ee.Date(callback);\n\n    // Filter the vector data to only include images from that day\n    var vectorDay = vectors.filterDate(date);\n    \n    // Filter the Sentinel-1 imagery to only include images from that day\n    var s1Day = s1.filterDate(date).max().updateMask(dem.lte(0));\n\n    // Use the viz function to visualize the results\n    viz(aoi, vectorDay, s1Day);\n};\n```\n\nThe analytical portion of the application is now complete. Now we have to build a user interface that lets us interact with the application.\n\n## Building a User Interface\n\nThere are four main steps in the process of creating the User Interface (UI):\n\n1.  Configure the drawing tools that allow the user to draw a polygon on the map. \n2.  Create some widgets \n\n### Drawing Tools \n\nWe eventually want to allow the user to draw a polygon on the map, and count the number of ships that fall within it. In order to do so, we need to set up a few functions related to the drawing tools that allow the user to do this. Among other things, we want to make sure that we're clearing the old geometries so that we're only ever conducting analysis inside the most recent user-drawn polygon, so we'll need to clear the old ones. We also want to specify the type of polygon the user can draw, which for ease will be a rectangle (you could change this to the actual \"polygon\" type if you wanted to draw more complex geometries).\n\n```js\nvar drawingTools = Map.drawingTools();\n\n// Remove any existing layers\nwhile (drawingTools.layers().length() > 0) {\n  var layer = drawingTools.layers().get(0);\n  drawingTools.layers().remove(layer);\n}\n\n// Add a dummy layer to the drawing tools object (the Suez Canal box)\nvar dummyGeometry = ui.Map.GeometryLayer({\n  geometries: null,\n})\n  .fromGeometry(suez)\n  .setShown(false);\n\n// Add the dummy layer to the drawing tools object\ndrawingTools.layers().add(dummyGeometry);\n\n\n// Create a function that clears existing geometries and lets the user draw a rectangle\nfunction drawPolygon() {\n  var layers = drawingTools.layers();\n  layers.get(0).geometries().remove(layers.get(0).geometries().get(0));\n  drawingTools.setShape(\"rectangle\");\n  drawingTools.draw();\n}\n```\n\n### Widgets\n\nThe control panel will eventually contain a few different widgets that allow the user to interact with the application. We'll start by creating a button that allows the user to draw a polygon on the map. We'll also create a slider that allows the user to adjust the size of the ships that are detected (remember, this manipualtes the \"scale\" parameter in the `reduceToVectors` function used in the detection process). The slider will have an accompanying label that tells the user what it does. \n\n```js \n// Create a button that allows the user to draw a polygon on the map\nvar drawButton = ui.Button({\n  label: \"ðŸ”º\" + \" Draw a Polygon\",\n  onClick: drawPolygon,\n  style: { stretch: \"horizontal\" },\n});\n\n// Create a slider that allows the user to adjust the size of the ships that are detected\nvar scaleSlider = ui.Slider({\n  min: 1,\n  max: 100,\n  value: 80,\n  step: 1,\n  onChange: daterangeVectors,\n  style: { width: \"70%\" },\n});\n\n// Create a label for the slider\nvar scaleLabel = ui.Label(\"Ship Size: \");\n\n// Create a panel that contains the slider and its label\nvar scalePanel = ui.Panel({\n  widgets: [scaleLabel, scaleSlider],\n  style: { stretch: \"horizontal\" },\n  layout: ui.Panel.Layout.Flow(\"horizontal\"),\n});\n```\n\nThe last widget we're going to define is the date slider. This widget will trigger the `daterangeVectors` function, which will filter the Sentinel-1 dataset to only include images from the selected year, and then run the detection process on the filtered dataset.\n\n```js\n// Specify the start and end dates for the date slider\nvar start = \"2014-01-01\";\nvar now = Date.now();\n\n// Create a date slider that allows the user to select a year\nvar dateSlider = ui.DateSlider({\n  value: \"2021-03-01\",\n  start: start,\n  end: now,\n  period: 365,\n  onChange: daterangeVectors,\n  style: { width: \"95%\" },\n});\n```\n\n### The Control Panel\n\nNow we're going to assemble all of the widgets we've just defined into one panel, alongsie some explanatory text. I'm adding a blank label to the panel as a placeholder for the chart, since it will be re-added to the panel every time the user changed the date on the date slider, the AOI, or the scale. \n\n```js\nvar controlPanel = ui.Panel({\n  widgets: [\n    ui.Label(\"SAR Ship Detection\", {\n      fontWeight: \"bold\",\n      fontSize: \"20px\",\n    }),\n    ui.Label(\n      \"This tool identifies ships using Synthetic Aperture Radar imagery. Use the date slider below to analyze a given year. Click on the graph to show ships on a given day.\",\n      { whiteSpace: \"wrap\" }\n    ),\n    dateSlider,\n    ui.Label(),\n    scalePanel,\n    ui.Label(\n      \"Click the button below and draw a rectangle on the map to count ships in a custom area.\"\n    ),\n    drawButton\n  ],\n  style: {maxWidth: \"400px\"},\n  layout: ui.Panel.Layout.flow(\"vertical\", true),\n});\n```\n\nOnce the control panel has been defined, we can add it to \n\n```js\n// Add the control panel to the map\nui.root.insert(0,controlPanel);\n\n// Trigger the daterangeVectors function when the user draws a polygon\ndrawingTools.onDraw(ui.util.debounce(daterangeVectors, 500));\n\n// Run the daterangeVectors function to initialize the map\ndaterangeVectors();\n```\n\nAnd there we have it. A fully functional, all weather, daytime/nighttime ship detection tool that doesn't rely on AIS data. Let's play around with it.\n\n## Taking it for a spin  \n\n### North Korea \n\nIn 2020, North Korea implemented one of the most severe COVID-19 lockdowns in the world including a near-total ban on [\"all cross-border exchanges, including trade, traffic, and tourism\".](https://thediplomat.com/2023/01/north-korea-likely-to-lift-pandemic-border-restrictions-in-2023/). Measures have been so severe that country appears to have experienced a significant [famine](https://foreignpolicy.com/2022/05/16/kim-north-korea-covid-outbreak-pandemic/). Though there were signs that things have gradually returned to normal, information on North Korea's economy is pretty hard to come by. Ship traffic in and out of the country's largest port, Nampo, is probably a pretty good indicator of the country's economic activity. \n\nBut we can't just head on down to Marine Tracker or other services that use AIS data to track ship movements. According to the [U.S. Treasury](https://home.treasury.gov/system/files/126/dprk_vessel_advisory_02232018.pdf), \"North Korean-flagged merchant vessels have been known to intentionally disable their AIS transponders to mask their movements. This tactic, whether employed by North Korean-flagged vessels or other vessels involved in trade with North Korea, could conceal the origin or destination of cargo destined for, or originating in, North Korea.\" They should know-- they're the ones imposing the sanctions that make it illegal to trade with North Korea. \n\nA New York Times [investigation](https://www.nytimes.com/2019/07/16/world/asia/north-korea-luxury-goods-sanctions.html) tracked the maritime voyage of luxury Mercedes cars from Germany to North Korea via the Netherlands, China, Japan, South Korea, and Russia. AIS transponders were turned off at several points throughout this journey, and the investigation had to rely on satellite imagery to fill in the gaps. \n\nThough they used high resolution optical imagery to follow individual ships, we want to identify lots of ships in a large area over a long period. That would get very expensive, and automatic ship detection in optical imagery is relatively difficult. Here's how our SAR tool fares when we draw a box in the bay of Nampo:\n\n![](/images/ships_north_korea.jpg)\n\nLooking at imagery from 2021, we can see ship traffic increasing from nearly zero to around 40 ships per day. \n\n### Ukraine\n\nOdessa is Ukraine's largest port. Following its invasion of Ukraine in February 2022, Russia instituted a naval blockade against Ukrainian ports. The impact of this blockade is clearly visible using the tool we've just built:\n\n![](/images/ships_ukraine.jpg)\n\nThe daily number of ships detected in the port of Odessa dropped from 40-50 to 0-5 following the invasion, and remained near zero until the blockade was lifted in September 2022.\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"monokai.theme","output-file":"W10_ships.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.40","bibliography":["references.bib"],"theme":{"dark":"darkly","light":"cosmo"},"code-copy":true,"linkcolor":"#34a832"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"W10_ships.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":true,"bibliography":["references.bib"],"documentclass":"scrreprt","header-includes":["\\makeatletter","\\@addtoreset{chapter}{part}","\\makeatother"]},"extensions":{"book":{"selfContainedOutput":true}}},"epub":{"identifier":{"display-name":"ePub","target-format":"epub","base-format":"epub"},"execute":{"fig-width":5,"fig-height":4,"fig-format":"png","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"epub","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":false,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"default-image-extension":"png","html-math-method":"mathml","to":"epub","output-file":"W10_ships.epub"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"bibliography":["references.bib"],"cover-image":"cover.png"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf","epub"]}